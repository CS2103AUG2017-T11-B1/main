= Directory of Contacts (DoC) - Developer Guide
:toc:
:toclevels: 3
:toc-title:
:toc-placement: macro
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
ifdef::env-github,env-browser[:outfilesuffix: .adoc]
:repoURL: https://github.com/se-edu/addressbook-level4/tree/master

By: `CS2103AUG2017-T11-B1`      Since: `Sep 2017` +
Adapted from AddressBook-Level4, by: `Team SE-EDU`      Since: `Jun 2016`      Licence: `MIT`

toc::[]

<<<

== Introduction

The Directory of Contacts (DoC) allows you to manage your contacts and events all within a single app. This guide will help you get to know the more important functions of the app and how they were implemented. From this, you will be better equipped to navigate around the codebase and further enhance the app as required.

== Setting up

=== Prerequisites

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer.
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first).
. Set up the correct JDK version for Gradle by:
.. Clicking `Configure` > `Project Defaults` > `Project Structure`.
.. Clicking `New...` and find the directory of the JDK.
. Click `Import Project`.
. Locate the `build.gradle` file and select it. Click `OK`.
. Click `Open as Project`.
. Click `OK` to accept the default settings.
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

. Run the `seedu.address.MainApp` and try a few commands.
. link:#testing[Run the tests] to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.md[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify:

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS).
. Select `Editor` > `Code Style` > `Java`.
. Click on the `Imports` tab to set the order as such:

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements.
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`.

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `se-edu/addressbook-level4` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `se-edu/addressbook-level4`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based).

<<<

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading the link:#architecture[Architecture] section.
2. Take a look at the section link:#suggested-programming-tasks-to-get-started[Suggested Programming Tasks to Get Started].

== Design

=== Architecture

image::Architecture.png[width="600"]
_Figure 3.1.1: Architecture Diagram_

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

<<<

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for the following:

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At change in selected contact: Increases the `viewCount` of the selected contact by one and updates the `Model`.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

link:#common-classes[*`Commons`*] represents a collection of classes used by multiple other components. Two of those classes that play important roles at the architecture level are as follows:

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design).
* `LogsCenter` : This class is used by many classes to write log messages to the App's log file.

The rest of the App consists of the following four components:

* link:#ui-component[*`UI`*] : Displays the UI of the App.
* link:#logic-component[*`Logic`*] : Executes the commands.
* link:#model-component[*`Model`*] : Holds the data of the App in-memory.
* link:#storage-component[*`Storage`*] : Reads data from, and writes data to, the hard disk.

Each of the four components does the following:

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

<<<

For example, the `Logic` component (see the class diagram given below) defines its API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

image::LogicClassDiagram.png[width="800"]
_Figure 3.1.2: Class Diagram of the Logic Component_

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

image::SDforDeletePerson.png[width="800"]
_Figure 3.1.3a: Component interactions for `delete 1` command (part 1)_

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the Address Book data are changed, instead of asking the `Storage` to save the updates to the hard disk.

<<<

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

image::SDforDeletePersonEventHandling.png[width="800"]
_Figure 3.1.3b: Component interactions for `delete 1` command (part 2)_

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

<<<

=== UI component

image::UiClassDiagram.PNG[width="800"]
_Figure 3.2.1: Structure of the UI Component_

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

As shown from the diagram above, the UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `EventListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`].

The `UI` component:

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

=== Logic component

image::LogicClassDiagram.png[width="800"]
_Figure 3.3.1: Structure of the Logic Component_

image::LogicCommandClassDiagram.png[width="800"]
_Figure 3.3.2: Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in Figure 3.3.1_

The above two diagrams show the structure of the `Logic` component and the structure of the commands in the `Logic` component.

<<<

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

When the user inputs a command, the `Logic` component takes these steps:

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a `Person`) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

image::DeletePersonSdForLogic.png[width="800"]
_Figure 3.3.3: Interactions Inside the Logic Component for the `delete 1` Command_

<<<

=== Model component

image::ModelClassDiagram.PNG[width="800"]
_Figure 3.4.1: Structure of the Model Component_

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

As shown in the diagram above, the `Model`:

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<ReadOnlyPerson>` and `ObservableList<ReadOnlyEvent>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

<<<

=== Storage component

image::StorageClassDiagram.PNG[width="800"]
_Figure 3.5.1: Structure of the Storage Component_

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

As shown in the diagram above, the `Storage` component:

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.

=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

<<<

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== Undo/Redo mechanism

==== Overview

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the address book (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]
_Figure 4.1.1: Inheritance Diagram for Commands_

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

<<<

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th contact in the address book. The current state of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command) (See Figure 4.1.2a).

image::UndoRedoStartingStackDiagram.png[width="800"]
_Figure 4.1.2a: Mechanism of UndoRedo Stack (Part 1)_

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/David ...` to add a new contact, as shown in the diagram below.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]
_Figure 4.1.2b: Mechanism of UndoRedo Stack (Part 2)_

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the contact was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the address book to the state before the `add` command executed, as can be seen in the diagram below.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]
_Figure 4.1.2c: Mechanism of UndoRedo Stack (Part 3)_

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

<<<

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]
_Figure 4.1.3: Sequence Diagram for UndoRedo Mechanism_

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow) (See Figure 4.1.4).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]
_Figure 4.1.4: UndoRedo Stack After Clear Command_

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution as shown in the following diagram:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]
_Figure 4.1.5: UndoRedo Stack After List Command_

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="200"]
_Figure 4.1.6: UndoRedo Activity Diagram_

==== Design Considerations

**Aspect:** Implementation of `UndoableCommand` +

**Chosen Implementation:** +
Add a new abstract method `executeUndoableCommand().` +
**Pros:** +
We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist. +
**Cons:** +
Hard for new developers to understand the template pattern. +

**Alternative:** +
Just override `execute().` +
**Pros:** +
Does not involve the template pattern, easier for new developers to understand. +
**Cons:** +
Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

---

**Aspect:** How undo & redo executes +

**Chosen Implementation:** +
Saves the entire address book. +
**Pros:** +
Easy to implement. +
**Cons:** +
May have performance issues in terms of memory usage. +

**Alternative:** +
Individual command knows how to undo/redo by itself. +
**Pros:** +
Will use less memory (e.g. for `delete`, just save the contact being deleted). +
**Cons:** +
 We must ensure that the implementation of each individual command are correct.

---

**Aspect:** Type of commands that can be undone/redone +

**Chosen Implementation:** Only include commands that modifies the address book (`add`, `clear`, `edit`). +
**Pros:** +
We only revert changes that are hard to change back (the view can easily be re-modified as no data are lost). +
**Cons:** +
User might think that undo also applies when the list is modified (undoing filtering for example), only to realize that it does not do that, after executing `undo`. +

**Alternative:** Include all commands. +
**Pros:** +
Might be more intuitive for the user. +
**Cons:** +
User have no way of skipping such commands if he or she just want to reset the state of the address book and not the view. +

**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].

---

**Aspect:** Data structure to support the undo/redo commands +

**Chosen Implementation:** +
Use separate stack for undo and redo. +
**Pros:** +
Easy to understand for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project. +
**Cons:** +
Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `UndoRedoStack`. +

**Alternative:** Use `HistoryManager` for undo/redo. +
**Pros:** +
We do not need to maintain a separate stack, and just reuse what is already in the codebase. +
**Cons:** +
Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things. +
// end::undoredo[]
// tag::eventDG[]
=== Event class mechanism
==== Summary
The `Event` class, which is located inside `Model`, is implemented with similar logic as `Person` class. We have introduced three commands that modifies the address book: `addE`, `editE` and `deleteE`, which extends `UndoableCommand`.
An `Event` consist of three sub-components: `Header`, `Desc` and `EventDate`. Commands such as `clear`, `undo` and `redo` can be used to alter events in the list as they deal with code that directly modifies the address book.

The `EventPanel` is incorporated into the address book `MainWindow` to display all the events inside the internal list using `ObservableList<ReadOnlyEvent>`. This process will be explained later on under the section `Event card`.

==== Event methods
As stated in the summary, the `Event` class contains three main methods: `addE`, `editE` and `deleteE`.
The execution flow is similar for all three methods on a higher level. We can demonstrate how different levels of components communicate with one another by referring to an example of `addE` command in the following sequence diagram:

image::AddEventDiagram.PNG[width="800"]
_Figure 4.2.1: AddEvent Sequence Diagram_

==== Exceptions
When the user input an event command with its parameters, the validity of the command word is checked inside the `AddressBookParser`. Next, the presence of the parameter prefixes is checked inside `AddEventCommandParser`.
An appropriate `ParseException` will be thrown if the command word or prefixes are incorrect.

Before modifying the list of events inside the address book, the system may throw exceptions due to some invalid parameters. Here are the possible exceptions:

* `EventNotFoundException`: This exception can be thrown by `editE` and `deleteE` command when the an invalid event index is provided by the user. The index needs to be within the size of the event list at the current state of the address book.
* `DuplicateEventException`: This exception can be thrown by `addE` and `editE` command. The system will first create an `Event` object with the input parameters, compare the object to all events residing in the event list and throw this exception if there is a duplicate found.
* `DateTimeParseException`: This exception can be thrown by `addE` and `editE` command when the input `EventDate` parameter is not a valid date. The date's format and validity is checked inside the `Event` class like this:

[source,java]
----
public EventDate(String eventDate) throws IllegalValueException {
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-mm-dd")
                    .withResolverStyle(ResolverStyle.STRICT);
    try {
        eventLocalDate = LocalDate.parse(eventDate, formatter);
    } catch (DateTimeParseException ex) {
        // ... throw message ...
    }
}
----

<<<

==== Event card
The `EventCard` class extends `UiPart<Region>` to represent a distinct part of the UI. The object properties of every event is assigned to a label held by an `EventCard`. The graphic scene is then constructed with the appropriate `FXML` files created to support the display of all events.

===== Design implementation
When the user starts the `MainApp`, the system calls the `UiManager` to create a new `MainWindow` and fills it with `EventListPanel` and other components. The displayed events are created by `UniqueEventList` and the binding of individual UI elements to the `EventCard` ensures that any changes to the parameter will be displayed in the `EventListPanel`.
The sequence diagram below illustrates the interaction between the `EventCard` and the `UiManager`:

image::EventCardDiagram.PNG[width="800"]
_Figure 4.2.2: EventCard Interaction Sequence Diagram_

The events on the `EventListPanel` is sorted based on `EventDate`. An event that is coming soon will appear at the top and events with later dates will be further down the list. Expired events will be pushed to the bottom of the list.
This sorting algorithm is introduced in `EventDateComparator` which implements `Comparator<Event>`.

<<<

The events follow a certain colored background based on its urgency. The visual guide below describes the color code used:

image::EventColorDiagram.png[width="600"]
_Figure 4.2.3: Event Colour Diagram_

==== Design Considerations
**Aspect(future enhancement):** How to implement adding/tagging of contacts into an `Event` using a `Person` list parameter +

**Chosen Implementation:** +
Add by the index of contact shown in the `PersonListPanel`. +
**Pros:** +
System only have to check for validity of index. Better performance compared to Alternative. +
**Cons:** +
Requires user to refer to the `PersonListPanel` before executing command to add contact into event's `Person` list. +

**Alternative:** Add by the name of contact in the `Person` list. +
**Pros:** +
Easier for users to add using names, do not need to refer to the `Person` list. +
**Cons:** +
System have to check through the list to check if the contact's name exist in the current address book.
// end::eventDG[]

// tag::oauth2[]
=== OAuth2 fulfilment mechanism
==== Overview
A command structure has been set-up to fulfil all commands requiring an authentication process against the OAuth2 protocol.
DoC currently only has two such commands, namely, `import` and `export`, which require this mechanism. Thus, it is noteworthy
that this implementation has been built for the express purpose of future extension.

An exciting possibility is an integration with Facebook, for automated
retrieval of extensive contact and event information. For example, we can populate a users' contact list on DoC, with his
Facebook friend list, which can include information on their birth dates, gender, and even their public profile pictures.

The OAuth2 authentication process is fulfilled with the help of the inbuilt `BrowserPanel`. This requires cross-component communication,
which is implemented in an event-driven manner.

The following class diagram illustrates the structure of this mechanism, and its' current applications: +

image::Oauth2ClassDiagram.PNG[width="100%"]
_Figure 4.3.1 OAuth2 Class Diagram_

An important requirement for all child classes of the `Oauth2Command` structure, is a valid `commandType` string of the format:
`SERVICEPROVIDER_functionality`. This is to allow quick identification in token extraction methods, as different service providers will append
the authentication token differently.

This is enforced in the constructor of the `Oauth2Command` class, and can be seen from the following code snippet:
[source,java]
----
protected Oauth2Command(String inputType)  {
    if (!inputTypeValid(inputType)) {
        assert false : "Child classes of Oauth2Command must provide a valid command type in the
            format: SERVICEPROVIDER_functionality";
    }
    commandType = inputType;
    commandCompleted = false;
}
----




==== Current usages

===== Import contacts to DoC from Google Contacts
The `import` command uses `Google Contacts` as a source, and retrieves all of the authenticated user's Google Contacts.
This comes in the form of a list of Google's `Person` objects, which are then converted to DoC `Person` objects with the
help of the `GooglePersonConverterUtil` class. The newly converted contacts are then stored
to the `Model` component of DoC.

===== Export contacts in DoC to Google Contacts
The `export` command converts all contacts currently stored in DoC, with the help of the `GooglePersonConverterUtil` class,
to a list of Google's `Person` class objects. The newly converted contacts are then exported to the authenticated users' Google Contacts.

<<<

==== Execution flow
===== Explanation
The implementation of both the `import` and `export` commands are very similar. These are the 5 sequential steps in the flow of execution
for the `import` command: +

.  The user input of `import` or `export` is parsed by the `AddressBookParser`, and a new instance of an `ImportCommand` or `ExportCommand` is returned to the `LogicManager`,
 which then calls the instance's `execute()` method. This is also known as the **input parsing process**. +

.  The `execute()` method of `import` and `export` then triggers the **authentication process** with the `BrowserPanel`. +

.  Upon successful authentication on an `import` command, the **HTTP request process** is executed, fetching a list.
of the authenticated user's Google Contacts from Google's servers. +

.  The **conversion process** then converts this list to a list of DoC `Person` objects. +

.  The list of converted DoC `Person` objects are then added to the `Model` component. +

**Note:** We will not discuss the **input parsing process** in further detail, as it is common to all commands in DoC,
and has been previously illustrated in section 3.3: Logic component.

===== Summary
The following diagram summarizes the execution flow and illustrates the parallel between the `import` and `export` commands:

image::import_export_parallel.png[width="80%"]
_Figure 4.3.2: Execution Flow of Import and Export Commands_

<<<

===== Authentication process
The **authentication process** is the more involved process of the 3. We can understand it better with the help of the following sequence diagram for the `import` command: +

image::AuthenticationSequenceDiagram.png[width="800"]
_Figure 4.3.3: Authentication Sequence Diagram_

This is a summary of the steps in the **authentication process**:

.  The `execute()` method of the `ImportCommand` is called from the `LogicManager`, firing an `Oauth2BrowserRequestEvent` to the `BrowserPanel`. +

.  The `BrowserPanel` handles this event and navigates to the **authentication URL*** provided by the event. +

.  The user successfully authenticates and grants DoC read permission of the users' Google Contacts. +

.  The `BrowserPanel` is redirected to the **success URL***. +

.  The `BrowserPanel` detects the URL change to the **success URL*** and extracts the authentication code appended to the URL,
this code is then attached to a `GoogleAuthenticationSuccessEvent` fired to the instance of `ImportCommand`. +

.  The `ImportCommand` instance handles the `GoogleAuthenticationSuccessEvent` and creates the `GoogleCredential` object. +

.  The **HTTP request process** ensues.

**Note:** The **authentication URL*** is generated by Google's `oauth2` client library. Choice of **success URL*** is discussed
later, under design considerations.


===== HTTP request process
With the `GoogleCredential` object generated at the end of the **authentication process**, we can now send HTTP requests
to the Google People API easily using Google's Java API client, specifically its' `PeopleService` class. Its documentation can be found in the following url: +
https://developers.google.com/resources/api-libraries/documentation/people/v1/java/latest/com/google/api/services/people/v1/PeopleService.html


===== Conversion process
The conversion process is handled entirely by the `GooglePersonConverterUtil`. Noteworthy design decisions are listed as follows: +
**Google Person -> DoC Person** +

* All Google `Person` objects with a null name or a null phone number are discarded.
* Google `Person` objects without an email or an address are given the placeholder constants `INVALID_EMAIL@INVALID.COM`, and
 `INVALID_ADDRESS PLEASE UPDATE THIS` respectively, in the resulting DoC `Person`.
* All DoC `Person` objects produced are given the tag `ImportedFromGoogle`.

**DoC Person -> Google Person** +

* DoC's `Name`, `Phone`, `Email` and `Address` objects are added as native Google `Person` attributes, with similar names while the `Tag`
object is added as a Google `Person` object's `UserDefined` attribute.
* `ProfilePic` cannot be exported due to Google Contact's restrictions.
* The produced Google `Person` objects are added to a contact group titled `Imported from DoC` on `Google Contacts`.

==== Design Considerations

**Aspect:** How a successful authentication is handled +

**Chosen implementation:** +
Use a hosted domain as the redirection URL for a successful authentication. This hosted domain will be the designated
**success URL*** the `BrowserPanel` listens for. After the authentication token is extracted from the URL, we then
redirect to a Google Contacts page. +
**Pros:** +
The underlying `HTTP GET` is sent to a domain under DoC's control, reducing the risk of authentication token leak. +
**Cons:** +
The `BrowserPanel` may display an error page temporarily if the hosted domain is down, however this will not be noticeable if redirection occurs fast. +

**Alternative:** +
Redirect to a Google Contacts page immediately. +
**Pros:** +
No risk of an error page being display. +
**Cons:** +
The underlying `HTTP GET` containing the authentication token is sent to an external domain.

'''

**Aspect:** Duplication handling +

**Chosen implementation:** +
Do not perform any duplication checks in the implementation of the `export` command. +
**Pros:** +
We avoid the overhead of having to first import all the user's Google contacts, storing them temporarily, then checking them against
DoC's `Model` component to sieve out non-duplicates. +
**Cons:** +
Multiple calls of the `export` command will result in duplicates being created on the user's Google contacts. +

**Alternative:** +
Implement a way to track changes within DoC's `Model` component, or a way to record export history.  +
**Pros:** +
We now can choose to export only modified or new `Person` objects in DoC. +
**Cons:** +
Cross-checking is still required against a user's Google contacts, as they can be modified externally.

**Note:** While the current choice may affect user experience, it is not app-breaking, and it is the compromise chosen
in this current version of DoC, due to the following redeeming factors:

- Google Contacts automatically flags possible duplicates, and offers a quick merging service.
- Contacts exported from DoC will be added to a designated "ImportedFromGoogle" contact group, and can be filtered out on Google Contacts easily.
// end::oauth2[]

<<<
// tag::email[]
=== Email

==== Overview

The `EmailCommand` is the main driver of this functionality. It links the logic in Addressbook and the content displayed on the Email browser.

image::EmailSequenceDiagram.png[width="800"]
_Figure 4.4.1: Email Sequence Diagram_

As seen from the picture above, the `AddressParser` will be able to distinguish the email command and direct it to the `EmailCommandParser`. Over there the recipient, subject and the body from the command line input is identified.

[NOTE]
Note that the `EmailCommandParser` will raise a `ParseException` if the `to/` is not filled. The `subject` and `body` fields are not compulsory.

Once identified, the `execute` function is called. This function in the `EmailCommand` would call the `updateEmailRecipient` function in the Model. Once the fields are updated properly, the `EmailCommand` will call the desktop mail app and fill in the necessary details.

The code below shows the link between the Java Application and the Desktop Mail App.
[source,java]
----
private void sendEmail(String emailTo) throws ParseException {
    if (emailTo.equalsIgnoreCase("")) {
        throw new ParseException("Invalid recipient email.");
    }
    Desktop desktop = Desktop.getDesktop();
    String url = "";
    URI mailTo;

    // the calling of the desktop mail app happens here
    try {
        url = "mailTo:" + emailTo + "?subject=" + this.subject
                + "&body=" + this.body;
        mailTo = new URI(url);
        desktop.mail(mailTo);
    }

    // ... catches the possible errors and throws the appropriate exceptions
}
----

<<<

==== Design Considerations

**Aspect:** Implementation of `Email` +

**Chosen Implementation:** +
Uses the inbuilt Email Application. +
**Pros:** +
The email authentication is done by that Email Application.  +
**Cons:** +
A new application has to be opened. +

**Alternative:** Make use of Gmail API. +
**Pros:** +
Can be emailed from the browser panel itself. +
**Cons:** +
The UI for GMail is very poor on `JavaFX WebView`.
// end::email[]

// tag::map[]
=== Map

==== Overview

image::Location.png[width="800"]
_Figure 4.5.1: Location Sequence Diagram_

As seen in the above diagram, an event based approach is used to display information on the Browser Panel.

[NOTE]
Note that the `LocationCommandParser` will raise a `ParseException` if the `INDEX` is not stated.

Once the Address book parser identifies the user command as a valid location command, it will make use of the Google Event bus to transmit the event.
The browser panel has subscribed for that particular event and therefore when the event is passed, the browser panel will pick it up and execute the function.
If the there is only one INDEX, This will eventually render the browser panel with Google Maps and a marker pointing at the address of the requested contact.
If there would be more than one INDEX present, then the direction from one place to another will be shown by the Google Maps.

This rendering of Google Maps is done via calling the URL over in `BrowserPanel` as shown in the code snippet below.

[source,java]
----
private void loadPersonLocation(List<ReadOnlyPerson> person) {
        // determines if it is either a location url or a route url based on the input
        String url = (person.size() == 1) ? GOOGLE_MAPS_URL_PLACE : GOOGLE_MAPS_URL_DIR;
        String result = "";
        for (ReadOnlyPerson ppl: person) {
            // ... logic to add the addresses to the result string ...
        }
        // loads the Google Map with the appropriate URL
        loadPage(url + result);
    }
----

==== Design Considerations

**Aspect:** Implementation of `map` +

**Chosen Implementation:** +
Add a new class that extends `Command` that uses the Google Maps URL. +
**Pros:** +
The map can be easily loaded without needing to call the GoogleMaps API.  +
**Cons:** +
Only functions that can be sent via URL can be used. +

**Alternative:** Make use of Google Maps API. +
**Pros:** +
More functions such as radius and many more could have been added. +
**Cons:** +
Take a longer time to load the map.
// end::map[]

<<<
// tag::removeTag[]

=== RemoveTag

==== Overview

The removeTag mechanism is facilitated by the `RemoveTagCommand` class which is inherited from the
`UndoableCommand` class. If the indexes are not stated, the particular tag is removed from all contacts.
Else, only those chosen indexes has its tag removed. All the indexes are based on the current list.

image::RemoveTagSequenceDiagram.png[width="800"]
_Figure 4.6.1: RemoveTag Sequence Diagram_

As shown in the diagram above, when the user executes the command `removeTag`, the `RemoveTagCommandParser` class will parse the tag and indexes if given, then call the `RemoveTagCommand`. In `RemoveTagCommand` the `execute()` function is called.
This will invoke the `removeTag` function that resides in the `LogicManager`, which will remove the specific tag from specific or all contacts based on the call made by the user. This changes will then be updated and stored.

The main logic behind `RemoveTagCommand` happens in the `ModelManager`. A brief overview of that code is shown below.

[source,java]
----
public void removeTag(ObservableList<ReadOnlyPerson> persons, Set<Tag> tag)
        throws PersonNotFoundException, IllegalValueException {
    int counter = 0; // to help in determining if the tag is valid

    // if an empty list of persons is provided, it is assumed to removeTags from everyone
    if (persons.isEmpty()) {
        persons.setAll(addressBook.getPersonList());
    }
    for (ReadOnlyPerson person : persons) {
        // only executed if the contact has that particular tag present
        if (!Collections.disjoint(person.getTags(), tag)) {
            // ... logic to removeTags from the respective contacts ...
            counter ++;
        }
    }

    // to check if the tag is valid
    if (counter == 0) {
        throw new IllegalValueException("The Tag is invalid!");
    }
}
----

[NOTE]
Note that the `removeTag` function will raise a `IllegalValueException` if the `tag` is not valid. This is shown in the above code snippet.

==== Design Considerations

**Aspect:** Implementation of `removeTag` +

**Chosen Implementation:** +
Directly removes a certain tag from specified or all contacts. +
**Pros:** +
Easier as multiple contacts are updated at one go.  +
**Cons:** +
It only can remove one tag at a time. If more tags has to be removed from multiple contacts, this function has to be called more times depending on the number of the tags that has to be removed. +

**Alternative:** Usage of `edit` command to remove the tags. +
**Pros:** +
One lesser command for the user to remember. +
**Cons:** +
It is very tiring for the user to update each and everyone of the contacts in the contact list, if he decided to remove the tag from everyone.
// end::removeTag[]

// tag::Find[]
=== Find

==== Overview

The `FindCommand` class is inherited from the
`Command` class.It allows the user to search his contacts either by the name of the contact or by the tag of the contact.


The existing `NameContainsKeywordsPredicate` was modified to suit the new needs.
The modified code is shown below.

[source,java]
----
public boolean test(ReadOnlyPerson person) {
        // ...  find by name logic ...
        if (validNames) {
            return validNames;
        }
        // ... find by tags logic ...
        if (validTags) {
            break;
        }
        return validTags;
    }
----

image::FindSequenceDiagram.png[width="800"]
_Figure 4.7.1: Find Sequence Diagram_

As shown in the diagram above, when the user executes the command `find`, the `FindCommandParser` class will parse the user's input, then call the `FindCommand`. In `FindCommand` the `execute()` function is called.
This will invoke the `updateFilteredPersonList` function that resides in the `LogicManager`, which will filter the contacts based on their name and tag that matches the call made by the user. This changes will then be updated on the `PersonalListPanel`.

==== Design Considerations

**Aspect:** Implementation of `find` +

**Chosen Implementation:** +
Directly find contacts based on both name and tag. +
**Pros:** +
One function that can be used to search by name and tag.  +
**Cons:** +
If name and tag are similar, the contacts with both the same name and tag will be shown. +

**Alternative:** Having two functions. One for find by name and another for find by tags. +
**Pros:** +
Easier to find a person by name or by tag, if both name and tag have similar Strings. +
**Cons:** +
Extra command for the user to remember.
// end::find[]

// tag::profilePic[]
=== UpdateProfilePic/DeleteProfilePic mechanism

==== Overview

The UpdateProfilePic/DeleteProfilePic mechanism is facilitated by a `ProfilePic` class, which is a property class of the `Person` class. It supports the updating and deleting of profile pictures of each contact. These two commands inherit from `Command`.

`ProfilePic` essentially stores a **valid** `URL` of an image that will be displayed as the contacts's profile picture. Whenever a new contact is added, the contact's `ProfilePic` property will be set to that of a default image. The command: `updateProfilePic` can then be called to change this property. When the command `deleteProfilePic` is called, the `ProfilePic` property of the selected contact will be changed back to the default profile picture.

Like the other properties of the `Person` class, the `ProfilePic` property will also be saved to the chosen storage file. If the image that is referred to by the `ProfilePic` is moved or deleted, the `ProfilePic` will reset back to the image of the default profile picture.

The `updateProfilePic`  command works by taking in the index of the chosen contact and updating this contact according to the `ProfilePic` given. To do so, the `updateProfilePic` command takes in a URL of the image that the profile picture is to be changed to. This will cause the app to instantiate a new `ProfilePic` object and check if the URL is valid and if it is valid, the app will proceed to update the contact with the new profile picture, otherwise an IllegalValueException will be thrown.

In addition, the image will be downloaded into a local folder called: `ProfilePics/` that is generated when the app initializes. This folder is created in the same folder as the `src` folder. (See code snippet below)
[source,java]
----
if (profilePic.toString().compareTo(ProfilePic.DEFAULT_URL) == 0) {
    deleteOldFile(personToUpdateProfilePic);
    newProfilePic = profilePic;
} else {
    String newFile;
    createNewDirectory();
    newFile = setFileName(personToUpdateProfilePic);
    createNewFile(newFile);
    newProfilePic = downloadImage(newFile);
}
----

The `deleteProfilePic` command works by taking in the index of the chosen contact and updating the `ProfilePic` property of the chosen contact to the default profile picture.

Below are the sequence diagrams of each command to illustrate how they work:

image::updateProfilePicSD.jpg[width="800"]
_Figure 4.8.1: UpdateProfilePic Sequence Diagram_

image::deleteProfilePicSD.jpg[width="800"]
_Figure 4.8.2: DeleteProfilePic Sequence Diagram_

==== Design Considerations

**Aspect:** Implementation of `updateProfilePic` +

**Chosen Implementation:** +
Add a new class that extends `Command`. +
**Pros:** +
The other properties of a contact can be quickly updated, using the `add` or `edit` commands, without waiting for an image to be loaded.  +
**Cons:** +
Users have to remember another command. +

**Alternative:** Just add the function to the `add` and `edit` commands. +
**Pros:** +
Users do not have to remember a new command. +
**Cons:** +
The image might take a while to load, so all the data takes longer to be updated.

---

**Aspect:** Implementation of `deleteProfilePic` +

**Chosen Implementation:** +
Add a new class that extends `Command`. +
**Pros:** +
A quick way to revert the profile picture back to default.  +
**Cons:** +
Redundant as it is a special case of `updateProfilePic` +

**Alternative:** Not have this command at all. +
**Pros:** +
Lesser commands for the user to remember. +
**Cons:** +
The user might not know what the default image URL is.

---

**Aspect:** Storage of images of profile pictures +

**Chosen Implementation:** +
Store the images in a local folder: `ProfilePics/`. +
**Pros:** +
After the initial download, subsequent retrieval of image for display can be done without visible lag and if the original image gets deleted or moved, the profile picture can still be displayed.  +
**Cons:** +
Initial download may cause a visible lag and freeze the UI for some time. +

**Alternative:** Not store the images +
**Pros:** +
No space requirement to store the images locally +
**Cons:** +
There might be a visible lag every time an image is displayed as a profile picture, if the image is too big and on the internet.
// end::profilePic[]

// tag::viewCount[]
=== ViewCount Tracking

==== Overview

The `viewCount` variable is a `private int` variable of the `Person` class. This variable is updated whenever a `PersonPanelSelectionChangedEvent` is raised. This means that whenever a contact is selected, whether by the `select` command or by clicking on the `PersonCard` on the UI, the contact associated with the selected `PersonCard` will have its `viewCount` variable incremented by 1.

To listen for the `PersonPanelSelectionChangedEvent`, a listener is placed in the `MainApp` object, which ensures that the `Model` associated to it is updated with the right `Person` object that has its `viewCount` updated. (See code snippet below)
[source,java]
----
private void handlePersonPanelSelectionChangedEvent(PersonPanelSelectionChangedEvent event) {
    logger.info(LogsCenter.getEventHandlingLogMessage(event));
    if (event.getNewSelection().person != null) {
        Person personSelected = new Person(event.getNewSelection().person);
        personSelected.setViewCount(personSelected.getViewCount() + 1);
        try {
            model.updatePerson(event.getNewSelection().person, personSelected);
        } catch (DuplicatePersonException dpe) {
            assert false : "Impossible to be duplicate";
        } catch (PersonNotFoundException pnfe) {
            assert false : "Impossible not to be found";
        }
    }
}
----

As the `viewCount` is not displayed on the UI, when this variable of a contact is updated, no `AddressBookChangedEvent` is raised, so the UI will not be refreshed unnecessarily.

Right before the app closes, the app will sort the `Person` objects in the `AddressBook` such that the `Person` objects will be displayed from highest `viewCount` to lowest. (See code snippet below)

[source,java]
----
public void sortByViewCount() {
    AddressBook addressBookToSort = new AddressBook(addressBook);
    ObservableList<ReadOnlyPerson> listToSort = addressBookToSort.getPersonList();
    ArrayList<ReadOnlyPerson> listToSortedCopy = new ArrayList<>();
    for (ReadOnlyPerson r : listToSort) {
        listToSortedCopy.add(r);
    }
    Collections.sort(listToSortedCopy, new ViewCountComparator());

    try {
        addressBookToSort.setPersons(listToSortedCopy);
    } catch (DuplicatePersonException dpe) {
        assert false : "Impossible to be duplicate";
    }

    resetData(addressBookToSort);
}
----

<<<

Below is the sequence diagram for how the `viewCount` object is updated:

image::updateViewCountSD.png[width="800"]
_Figure 4.9.1: UpdateViewCount Sequence Diagram_

==== Design Considerations

**Aspect:** Implementation of `viewCount` +

**Chosen Implementation:** +
Add a new variable to the `Person` class. +
**Pros:** +
No extra classes have to be created and it is clear which `Person` has a `viewCount` of what value. +
**Cons:** +
The `Model` has to be updated every time a new `PersonCard` is selected. +

**Alternative:** Track all the `viewCount` in a separate file or class. +
**Pros:** +
`Model` does not need to be updated and no existing class will be changed. +
**Cons:** +
File IO will be required for the saving of the list or the list has to be converted into XML and stored with the rest of the data is `addressbook.xml`.

---

<<<

**Aspect:** Updating of `Model` +

**Chosen Implementation:** +
Update `Model` without raising `AddressBookChangedEvent`. +
**Pros:** +

No unnecessary refreshing of the UI.     +
**Cons:** +
The `viewCount` variable of each `Person` is only saved to `addressbook.xml` only when the app stops or when the next `AddressBookChangedEvent` is raised. +

**Alternative:** Update `Model` normally. +

**Pros:** +
The `addressbook.xml` file is always updated once any value is changed. +
**Cons:** +
The UI will be refreshed unnecessarily, which may cause a visible lag if large image files are reloaded.

---

**Aspect:** Sorting by `viewCount` +

**Chosen Implementation:** +
Sort right before app stops. +
**Pros:** +
When app is started the next time, it can be started immediately, without having to perform the sort. +
**Cons:** +
The app might lag a bit when stopping. +

**Alternative:** Sort right before app starts. +
**Pros:** +
The app will stop quickly. +
**Cons:** +
The app will take a while to start. +
**Alternative 3:** Whenever a viewCount is changed. +
**Pros:** The app will always show the updated order. +
**Cons:** The app will lag slightly each time a `PersonCard` is selected.
// end::viewCount[]

<<<
// tag::unknowncommand[]
=== Unknown input parsing

==== Overview
To enhance user experience, a similarity-matching mechanism is employed to detect and parse unknown user input, matching them
to probable system-recognized commands.
The Levenshtein distance is used as a metric to measure similarity.

Here's a brief explanation of this metric: +
----
The Levenshtein distance between two strings, is the minimum number of insertion, deletion or
substitution operations required to transform one string to the other.
----

This mechanism is achieved with an enhancement on the original `AddressBookParser`, and the introduction of a new class, `UnknownCommand`.

==== Execution flow
===== Explanation
When a unknown input is entered, the `AddressBookParser` instantiates an `UnknownCommand` object with this input.
The 'AddressBookParser' then calls the `suggestionFound()` method of this instance. This method proceeds to match the unknown input against
a list of system-recognized command words. If a match is found, we instantiate the suggested command within the `UnknownCommand` object,
and prompt the user for a response. If the user accepts the suggestion, we retrieve the instance of the suggested command and execute it.


**Note:** +

- If the minimum Levenshtein distance is shared by two matches, the lexicographically smaller match will be chosen.

- We reject any unknown input, whose `commandWord` exceeds the maximum acceptable length. This number is chosen based on the set
maximum acceptable Levenshtein distance and the length of the longest system-recognized `commandWord` in DoC:

----
maximum acceptable length = length of longest system-recognized `commandWord` + maximum acceptable Levenshtein distance

Current state of DoC: 18 = 16 + 2
----

- If a match is found and the input contains invalid parameters, we do not prompt the user for a response. Instead we prompt
the user with an invalid command format message, and a format guideline on the matched command.

===== Summary
The following activity diagram illustrates the the execution flow of the `parseCommand()` method, of the `AddressBookParser`,
with this enhancement in place:

image::ParseCommandActivityDiagram.png[width="100%"]
_Figure 4.10.1: ParseCommand Activity Diagram_

As shown in the diagram above, actions enclosed in a green box are the enhancements applied to the original `AddressBookParser`,
for the purpose of this mechanism.

To better understand the underlying logic of this enhancement, you can refer to the following code snippets: +

----
if (correctionPrompted) {
    if (userAcceptsSuggestion(commandWord)) {
        Command suggestedCommand = unknownCommand.getSuggestedCommand();
        resetCorrectionChecker();
        return suggestedCommand;
    } else {
        resetCorrectionChecker();
    }
}
.
.
----
As shown in the snippet above, once a correction has been prompted, the prompting mechanism will be reset one command later
even if we do not receive a positive response from the user. This means that we only offer the user one window of
opportunity to accept the suggestion.

Responses that are not recognized in the `userAcceptsSuggestion(commandWord)` method, will be parsed as regular input. This means that we do
not require a negative response to a correction prompt.

Processing of unknown user input, is performed in the default case of the following switch:

----
.
.
switch (commandWord) {
    .
    .
    default:
        unknownCommand = new UnknownCommand(commandWord, arguments);
        if (unknownCommand.suggestionFound()) {
            correctionPrompted = true;
            return unknownCommand;
        } else {
            unknownCommand = null;
        }
        throw new ParseException(MESSAGE_UNKNOWN_COMMAND);
}
----
As shown in the snippet above, when a possible match is found, we set the boolean `correctionPrompted` to `true`, to begin checking for a
response to our prompt, which is shown in the previous code snippet.


==== Design considerations

**Aspect:** Choice of acceptable Levenshtein distance +

**Chosen implementation:** +
Set the maximum acceptable Levenshtein distance to 1 less than the length of the shortest command in DoC, which is currently 3. +
**Pros:** +
The similarity matching will be more likely to yield relevant result, than if the Levenshtein distance were to be set at the length of the shortest command in DoC or higher.
For example, the current shortest command in DoC is 'add' with a length of 3. If were to set the maximum acceptable Levenshtein distance to 3, any random 3 letter sequence would be matched successfully. +
**Cons:** +
Typos on longer commands have a higher propensity to produce a string with a Levenshtein distance of more than 2.
These cannot be detected with this implementation. +

**Alternative 1:** +
Set a maximum acceptable Levenshtein distance of 3 or higher. +
**Pros:** +
Stronger similarity matching capabilities. +
**Cons:** +
Random user input might yield positive matches. +

**Alternative 2:** +
Lengthen sytem-recognized command words. +
**Pros:** +
We can set a higher maximum acceptable Levenshtein distance without the cons mentioned in  alternative 1. +
**Cons:** +
The user would have to type more for each command.

---

**Aspect:** Parsing user response after a suggestion is prompted +

**Chosen implementation:** +
DoC prompts the user for a response of "yes" or "y", which executes the suggested command. Upon any another response,
the system discards the suggested command and begins the parsing process again. +
**Pros:** +
If the mechanism has wrongly matched an unknown input, the user can simply ignore the suggestion prompt and continue without
further action. +
**Cons:** +
The user might infer that a response of "no" or "n" is required to reject the suggestion, and enters an input accordingly.
This may begin a loop that proceeds ad infinitum. +

**Alternative 1:** +
DoC prompts the user for a response of "no" or "n" to indicate rejection. +
**Pros:** +
The handling would be more intuitive to the user. +
**Cons:** +
An extra step is presented to the user on a wrong match, affecting the user's experience.

**Note:** In our chosen implementation, we mitigate the mentioned cons by including explicit instructions in the suggestion prompt,
that a response is only required if the user accepts the match.
// end::unknowncommand[]

<<<

== Logging

=== Overview

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations, as such:

* The logging level can be controlled using the `logLevel` setting in the configuration file (See link:#configuration[Configuration])
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* The log messages are currently output through: `Console` and to a `.log` file.

*Logging Levels:*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

<<<

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format:

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` folder to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot on the next page.

image::chrome_save_as_pdf.png[width="300"]
_Figure 6.3.1 : Saving documentation as PDF files in Chrome_

== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`.
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`.

<<<

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`).

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`).

=== Types of tests

We have two types of tests:

*  *GUI Tests* - These are tests involving the GUI. They include:
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
*  *Non-GUI Tests* - These are tests not involving the GUI. They include:
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`

<<<

=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`.
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size). +
b. Require developers to download those libraries manually (this creates extra work for developers).

<<<

[appendix]
== Suggested Programming Tasks to Get Started

Suggested path for new programmers:

1. First, add small local-impact (i.e. the impact of the change does not go beyond the component) enhancements to one component at a time. Some suggestions are given in this section link:#improving-each-component[Improving a Component].

2. Next, add a feature that touches multiple components to learn how to implement an end-to-end feature across all components. The section link:#creating-a-new-command-code-remark-code[Creating a new command: `remark`] explains how to go about adding such a feature.

=== Improving each component

Each individual exercise in this section is component-based (i.e. you would not need to modify the other components to get it to work).

[discrete]
==== `Logic` component

[TIP]
Do take a look at the link:#logic-component[Design: Logic Component] section before attempting to modify the `Logic` component.

. Add a shorthand equivalent alias for each of the individual commands. For example, besides typing `clear`, the user can also type `c` to remove all persons in the list.
+
****
* Hints
** Just like we store each individual command word constant `COMMAND_WORD` inside `*Command.java` (e.g.  link:{repoURL}/src/main/java/seedu/address/logic/commands/FindCommand.java[`FindCommand#COMMAND_WORD`], link:{repoURL}/src/main/java/seedu/address/logic/commands/DeleteCommand.java[`DeleteCommand#COMMAND_WORD`]), you need a new constant for aliases as well (e.g. `FindCommand#COMMAND_ALIAS`).
** link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser`] is responsible for analyzing command words.
* Solution
** Modify the switch statement in link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser#parseCommand(String)`] such that both the proper command word and alias can be used to execute the same intended command.
** See this https://github.com/se-edu/addressbook-level4/pull/590/files[PR] for the full solution.
****

[discrete]
==== `Model` component

[TIP]
Do take a look at the link:#model-component[Design: Model Component] section before attempting to modify the `Model` component.

. Add a `removeTag(Tag)` method. The specified tag will be removed from everyone in the address book.
+
****
* Hints
** The link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model`] API needs to be updated.
**  Find out which of the existing API methods in  link:{repoURL}/src/main/java/seedu/address/model/AddressBook.java[`AddressBook`] and link:{repoURL}/src/main/java/seedu/address/model/person/Person.java[`Person`] classes can be used to implement the tag removal logic. link:{repoURL}/src/main/java/seedu/address/model/AddressBook.java[`AddressBook`] allows you to update a person, and link:{repoURL}/src/main/java/seedu/address/model/person/Person.java[`Person`] allows you to update the tags.
* Solution
** Add the implementation of `deleteTag(Tag)` method in link:{repoURL}/src/main/java/seedu/address/model/ModelManager.java[`ModelManager`]. Loop through each person, and remove the `tag` from each person.
** See this https://github.com/se-edu/addressbook-level4/pull/591/files[PR] for the full solution.
****

[discrete]
==== `Ui` component

[TIP]
Do take a look at the link:#ui-component[Design: UI Component] section before attempting to modify the `UI` component.

. Use different colors for different tags inside person cards. For example, `friends` tags can be all in grey, and `colleagues` tags can be all in red.
+
**Before**
+
image::getting-started-ui-tag-before.png[width="300"]
+
**After**
+
image::getting-started-ui-tag-after.png[width="300"]
+
****
* Hints
** The tag labels are created inside link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard#initTags(ReadOnlyPerson)`] (`new Label(tag.tagName)`). https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/Label.html[JavaFX's `Label` class] allows you to modify the style of each Label, such as changing its color.
** Use the .css attribute `-fx-background-color` to add a color.
* Solution
** See this https://github.com/se-edu/addressbook-level4/pull/592/files[PR] for the full solution.
****

. Modify link:{repoURL}/src/main/java/seedu/address/commons/events/ui/NewResultAvailableEvent.java[`NewResultAvailableEvent`] such that link:{repoURL}/src/main/java/seedu/address/ui/ResultDisplay.java[`ResultDisplay`] can show a different style on error (currently it shows the same regardless of errors).
+
**Before**
+
image::getting-started-ui-result-before.png[width="200"]
+
**After**
+
image::getting-started-ui-result-after.png[width="200"]
+
****
* Hints
** link:{repoURL}/src/main/java/seedu/address/commons/events/ui/NewResultAvailableEvent.java[`NewResultAvailableEvent`] is raised by link:{repoURL}/src/main/java/seedu/address/ui/CommandBox.java[`CommandBox`] which also knows whether the result is a success or failure, and is caught by link:{repoURL}/src/main/java/seedu/address/ui/ResultDisplay.java[`ResultDisplay`] which is where we want to change the style to.
** Refer to link:{repoURL}/src/main/java/seedu/address/ui/CommandBox.java[`CommandBox`] for an example on how to display an error.
* Solution
** Modify link:{repoURL}/src/main/java/seedu/address/commons/events/ui/NewResultAvailableEvent.java[`NewResultAvailableEvent`] 's constructor so that users of the event can indicate whether an error has occurred.
** Modify link:{repoURL}/src/main/java/seedu/address/ui/ResultDisplay.java[`ResultDisplay#handleNewResultAvailableEvent(event)`] to react to this event appropriately.
** See this https://github.com/se-edu/addressbook-level4/pull/593/files[PR] for the full solution.
****

. Modify the link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter`] to show the total number of people in the address book.
+
**Before**
+
image::getting-started-ui-status-before.png[width="500"]
+
**After**
+
image::getting-started-ui-status-after.png[width="500"]
+
****
* Hints
** link:{repoURL}/src/main/resources/view/StatusBarFooter.fxml[`StatusBarFooter.fxml`] will need a new `StatusBar`. Be sure to set the `GridPane.columnIndex` properly for each `StatusBar` to avoid misalignment!
** link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter`] needs to initialize the status bar on application start, and to update it accordingly whenever the address book is updated.
* Solution
** Modify the constructor of link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter`] to take in the number of persons when the application just started.
** Use link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter#handleAddressBookChangedEvent(AddressBookChangedEvent)`] to update the number of persons whenever there are new changes to the addressbook.
** See this https://github.com/se-edu/addressbook-level4/pull/596/files[PR] for the full solution.
****

[discrete]
==== `Storage` component

[TIP]
Do take a look at the link:#storage-component[Design: Storage Component] section before attempting to modify the `Storage` component.

. Add a new method `backupAddressBook(ReadOnlyAddressBook)`, so that the address book can be saved in a fixed temporary location.
+
****
* Hint
** Add the API method in link:{repoURL}/src/main/java/seedu/address/storage/AddressBookStorage.java[`AddressBookStorage`] interface.
** Implement the logic in link:{repoURL}/src/main/java/seedu/address/storage/StorageManager.java[`StorageManager`] class.
* Solution
** See this https://github.com/se-edu/addressbook-level4/pull/594/files[PR] for the full solution.
****

=== Creating a new command: `remark`

By creating this command, you will get a chance to learn how to implement a feature end-to-end, touching all major components of the app.

==== Description
Edits the remark for a person specified in the `INDEX`. +
Format: `remark INDEX r/[REMARK]`

<<<

Examples:

* `remark 1 r/Likes to drink coffee.` +
Edits the remark for the first person to `Likes to drink coffee.`
* `remark 1 r/` +
Removes the remark for the first person.

==== Step-by-step Instructions

===== [Step 1] Logic: Teach the app to accept 'remark' which does nothing
Let's start by teaching the application how to parse a `remark` command. We will add the logic of `remark` later.

**Main:**

. Add a `RemarkCommand` that extends link:{repoURL}/src/main/java/seedu/address/logic/commands/UndoableCommand.java[`UndoableCommand`]. Upon execution, it should just throw an `Exception`.
. Modify link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser`] to accept a `RemarkCommand`.

**Tests:**

. Add `RemarkCommandTest` that tests that `executeUndoableCommand()` throws an Exception.
. Add new test method to link:{repoURL}/src/test/java/seedu/address/logic/parser/AddressBookParserTest.java[`AddressBookParserTest`], which tests that typing "remark" returns an instance of `RemarkCommand`.

===== [Step 2] Logic: Teach the app to accept 'remark' arguments
Let's teach the application to parse arguments that our `remark` command will accept. E.g. `1 r/Likes to drink coffee.`

**Main:**

. Modify `RemarkCommand` to take in an `Index` and `String` and print those two parameters as the error message.
. Add `RemarkCommandParser` that knows how to parse two arguments, one index and one with prefix 'r/'.
. Modify link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser`] to use the newly implemented `RemarkCommandParser`.

**Tests:**

. Modify `RemarkCommandTest` to test the `RemarkCommand#equals()` method.
. Add `RemarkCommandParserTest` that tests different boundary values
for `RemarkCommandParser`.
. Modify link:{repoURL}/src/test/java/seedu/address/logic/parser/AddressBookParserTest.java[`AddressBookParserTest`] to test that the correct command is generated according to the user input.

===== [Step 3] Ui: Add a placeholder for remark in `PersonCard`
Let's add a placeholder on all our link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`] s to display a remark for each person later.

**Main:**

. Add a `Label` with any random text inside link:{repoURL}/src/main/resources/view/PersonListCard.fxml[`PersonListCard.fxml`].
. Add FXML annotation in link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`] to tie the variable to the actual label.

**Tests:**

. Modify link:{repoURL}/src/test/java/guitests/guihandles/PersonCardHandle.java[`PersonCardHandle`] so that future tests can read the contents of the remark label.

===== [Step 4] Model: Add `Remark` class
We have to properly encapsulate the remark in our link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`] class. Instead of just using a `String`, let's follow the conventional class structure that the codebase already uses by adding a `Remark` class.

<<<

**Main:**

. Add `Remark` to model component (you can copy from link:{repoURL}/src/main/java/seedu/address/model/person/Address.java[`Address`], remove the regex and change the names accordingly).
. Modify `RemarkCommand` to now take in a `Remark` instead of a `String`.

**Tests:**

. Add test for `Remark`, to test the `Remark#equals()` method.

===== [Step 5] Model: Modify `ReadOnlyPerson` to support a `Remark` field
Now we have the `Remark` class, we need to actually use it inside link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`].

**Main:**

. Add three methods `setRemark(Remark)`, `getRemark()` and `remarkProperty()`. Be sure to implement these newly created methods in link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`Person`], which implements the link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`] interface.
. You may assume that the user will not be able to use the `add` and `edit` commands to modify the remarks field (i.e. the person will be created without a remark).
. Modify link:{repoURL}/src/main/java/seedu/address/model/util/SampleDataUtil.java/[`SampleDataUtil`] to add remarks for the sample data (delete your `addressBook.xml` so that the application will load the sample data when you launch it.)

===== [Step 6] Storage: Add `Remark` field to `XmlAdaptedPerson` class
We now have `Remark` s for `Person` s, but they will be gone when we exit the application. Let's modify link:{repoURL}/src/main/java/seedu/address/storage/XmlAdaptedPerson.java[`XmlAdaptedPerson`] to include a `Remark` field so that it will be saved.

**Main:**

. Add a new Xml field for `Remark`.
. Be sure to modify the logic of the constructor and `toModelType()`, which handles the conversion to/from  link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`].

**Tests:**

. Fix `validAddressBook.xml` such that the XML tests will not fail due to a missing `<remark>` element.

===== [Step 7] Ui: Connect `Remark` field to `PersonCard`
Our remark label in link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`] is still a placeholder. Let's bring it to life by binding it with the actual `remark` field.

**Main:**

. Modify link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard#bindListeners()`] to add the binding for `remark`.

**Tests:**

. Modify link:{repoURL}/src/test/java/seedu/address/ui/testutil/GuiTestAssert.java[`GuiTestAssert#assertCardDisplaysPerson(...)`] so that it will compare the remark label.
. In link:{repoURL}/src/test/java/seedu/address/ui/PersonCardTest.java[`PersonCardTest`], call `personWithTags.setRemark(ALICE.getRemark())` to test that changes in the link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`Person`] 's remark correctly updates the corresponding link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`].

===== [Step 8] Logic: Implement `RemarkCommand#execute()` logic
We now have everything set up... but we still can't modify the remarks. Let's finish it up by adding in actual logic for our `remark` command.

**Main:**

. Replace the logic in `RemarkCommand#execute()` (that currently just throws an `Exception`), with the actual logic to modify the remarks of a person.

**Tests:**

. Update `RemarkCommandTest` to test that the `execute()` logic works.

==== Full Solution

See this https://github.com/se-edu/addressbook-level4/pull/599[PR] for the step-by-step solution.

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="100%",cols="10%,10%,30%,30%,20%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can... |Status
|`* * *` |user |import contacts from an existing source |use the app with less set-up time | Available since DoC v1.1
|`* * *` |user |add more fields to a contact |cater to contacts with multiple emails, phone numbers, etc |
|`* * *` |user |view frequently contacted contacts on the top of the list | |
|`* * *` |user |delete multiple people |delete groups faster |
|`* * *` |user |create a backup of my contacts |avoid losing them |
|`* * *` |user |search for contacts by common tags | |
|`* * *` |user |favourite a contact | |

|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App |AddressBook Level 4: `delete`
|`* * *` |user |add a new person | |AddressBook Level 4: `add`
|`* * *` |user |list all my contacts | |AddressBook Level 4: `list`
|`* * *` |user |update each contact's information | |AddressBook Level 4: `edit`
|`* * *` |user |find a person by name |locate details of persons without having to go through the entire list |AddressBook Level 4: `find`
|`* * *` |user |delete a person |remove entries that I no longer need |AddressBook Level 4: `delete`
|`* * *` |user |select a person |Automatically perform a google search on them |AddressBook Level 4: `delete`
|`* * *` |user |view history of recent commands | |AddressBook Level 4: `history`
|`* * *` |user |undo a previous command |revert any accidental changes |AddressBook Level 4: `undo`
|`* * *` |user |redo an undone command | |AddressBook Level 4: `redo`
|`* * *` |user |delete all contacts | |AddressBook Level 4: `clear`
|`* * *` |user |exit the program | |AddressBook Level 4: `exit`


|`* *` |user |call a person | |
|`* *` |user |email a person | |
|`* *` |user |retrieve physical location of a person | |
|`* *` |user |send feedback to the developer |to improve the app |
|`* *` |user |use shorthands of commands |use commands faster |
|`* *` |user |share my contacts with other users |save time on adding |
|`* *` |user |customize the appearance of the app | |
|`* *` |user |swap two contacts in the list |view in the desired order |
|`* *` |user |view user page of contacts who also use the app | |
|`* *` |user |view the profile picture of a contact | |
|`* *` |user |enable auto-correct for slightly mistyped commands | |
|`* *` |user |store my contacts on an online database | |
|`* *` |user |access the app using my mobile phone | |
|`* *` |user |undo my latest command | |
|`* *` |user |hide link:#private-contact-detail[private contact details] by default |minimize chance of someone else seeing them by accident |
|`* *` |user |hide private contact details by default |minimize chance of someone else seeing them by accident |AddressBook Level 4

|`*` |user with many persons in the address book |sort persons by name |locate a person easily |
|=======================================================================

{More to be added}

[appendix]
== Use Cases

(For all use cases below, the *System* is the `AddressBook` and the *Actor* is the `user`, unless specified otherwise)

[none]
=== Use case: Delete person

*MSS*

1.  User requests to list persons.
2.  AddressBook shows a list of persons.
3.  User requests to delete a specific person in the list.
4.  AddressBook deletes the person.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.

+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

+
Use case ends.

*Extensions*

[none]
=== Use case: Undo command

*MSS*

1.  User requests to undo command.
2.  AddressBook shows the latest command and ask for confirmation.
3.  User confirms.
4.  AddressBook reverts to the state before the command.
+
Use case ends.

<<<

*Extensions*

[none]
* 1a. The user has not input any commands.
+
Use case ends.

* 2a. The latest command does not involve altering the AddressBook.
+
[none]
** 2a1. AddressBook shows an error message.
+
Use case ends.

[none]
=== Use case: Swap Persons

*MSS*

1.  User requests to list persons.
2.  AddressBook shows a list of persons.
3.  User request to swap the indexes of two persons in the list.
4.  AddressBook swaps the two persons.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.
* 3a. The given index(s) is/are invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

[none]
=== Use case: Sort command

*MSS*

1.  User requests to sort persons.
2.  AddressBook shows a list of sorted persons.
* 2a. The list will be altered and shows the sorted list.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

[none]
=== Use case: Delete multiple persons

*MSS*

1.  User requests to list persons.
2.  AddressBook shows a list of persons.
3.  User requests to delete multiple person in the list.
4.  AddressBook delete the persons.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

[none]
=== Use case: Import existing contacts from google

*MSS*

1.  User requests to import existing contacts.
2.  DoC prompts google login for authentication.
3.  User enters authentication information.
4.  DoC prompts user to grant access to his Google Contacts.
5.  User grants access.
6.  DoC updates contact list.
+
Use case ends.

*Extensions*

[none]
* 3a. User fails to login.
+
Use case resumes at step 2.

* 5a. User refuses to grant access
+
Use case ends


[none]
=== Use case: Add person

*MSS*

1.  User requests to add person to the address book.
2.  AddressBook adds the person.
+
Use case ends.

*Extensions*

[none]
* 2a. The given format is invalid.
+
[none]
** 2a1. AddressBook shows an error message.
+
Use case resumes at step 2.

[none]
=== Use case: Favourite person

*MSS*

1.  User requests to list persons.
2.  AddressBook shows a list of persons.
3.  User requests to favourite a specific person in the list.
4.  AddressBook favourites the person.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.
* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

{More to be added}


[appendix]
== Non Functional Requirements

.  Should work on any link:#mainstream-os[mainstream OS] as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  The system should respond under a second.
.  The system should be able to recover the data from its backup version.
.  The system should work on both 32-bit and 64-bit environments.
.  The system should provide necessary assistance in usage and operation.
.  The system should be accessible with web-enabled mobile devices.
.  The font colour of the text and the colour of the display panel should be contrasting to improve readability.
.  The user interface should be intuitive enough for users who are not IT-savvy.

{More to be added}

[appendix]
== Glossary

[[mainstream-os]]
Mainstream OS

....
Windows, Linux, Unix, OS-X
....

[[private-contact-detail]]
Private contact detail

....
A contact detail that is not meant to be shared with others
....

[appendix]
== Product Survey

*DoC*

Author: Students from the NUS School of Computing

Pros:

* Allows import and export of Contacts to and from Google Contacts.
* Allows offline contact information.
* Allows mass emailing.
* Allows managing of events.

Cons:

* Only a desktop app.
* Needs internet to access certain features.
